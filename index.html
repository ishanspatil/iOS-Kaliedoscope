<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<title>Kaleidoscope Cam</title>
<style>
  :root { color-scheme: dark; }
  body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; background:#000; color:#fff; }
  #wrap { display:flex; flex-direction:column; gap:10px; padding:12px; max-width:900px; margin:0 auto; }
  #c { width:100%; aspect-ratio: 9 / 16; background:#111; border-radius:12px; }
  #controls { display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
  fieldset { border:1px solid #333; border-radius:10px; padding:10px; }
  label { display:block; font-size:12px; opacity:.8; margin-bottom:6px; }
  input[type=range]{ width:100%; }
  button, select { padding:10px 12px; background:#111; color:#fff; border:1px solid #333; border-radius:10px; }
  #row { display:flex; gap:10px; }
  video { display:none; }
</style>
</head>
<body>
<div id="wrap">
  <canvas id="c"></canvas>
  <div id="row">
    <button id="start">Start</button>
    <button id="flip">Flip Camera</button>
    <label style="flex:1">
      <select id="device"></select>
    </label>
  </div>
  <div id="controls">
    <fieldset>
      <label>Segments: <span id="segVal">8</span></label>
      <input id="segments" type="range" min="2" max="24" step="1" value="8">
      <label>Angle</label>
      <input id="angle" type="range" min="0" max="6.2832" step="0.005" value="0.3">
    </fieldset>
    <fieldset>
      <label>Zoom</label>
      <input id="zoom" type="range" min="0.7" max="3.0" step="0.01" value="1.2">
      <label><input id="mirror" type="checkbox" checked> Mirror wedge</label>
    </fieldset>
  </div>
</div>

<video id="v" playsinline muted></video>

<script>
(async () => {
  const canvas = document.getElementById('c');
  const gl = canvas.getContext('webgl', { antialias: false, preserveDrawingBuffer: false });
  if (!gl) { alert('WebGL not available'); return; }

  const vsSrc = `
    attribute vec2 a_pos;
    varying vec2 v_uv;
    void main() {
      v_uv = a_pos * 0.5 + 0.5;
      gl_Position = vec4(a_pos, 0.0, 1.0);
    }
  `;

  const fsSrc = `
    precision highp float;
    varying vec2 v_uv;
    uniform sampler2D u_tex;
    uniform vec2 u_res;
    uniform float u_angle;
    uniform float u_zoom;
    uniform float u_segments;
    uniform float u_mirror;
    // Convert uv to centered coords with aspect correction
    vec2 toCentered(vec2 uv, float aspect) {
      vec2 p = uv - 0.5;
      p.x *= aspect;
      return p;
    }
    vec2 fromCentered(vec2 p, float aspect) {
      p.x /= aspect;
      return p + 0.5;
    }
    void main(){
      float TAU = 6.28318530718;
      float aspect = u_res.x / u_res.y;

      // centered coords, zoom, and angle offset
      vec2 p = toCentered(v_uv, aspect) * u_zoom;

      // polar
      float r = length(p);
      float a = atan(p.y, p.x) + u_angle;

      // fold into wedge
      float sector = TAU / max(2.0, u_segments);
      a = mod(a, sector);
      if (u_mirror > 0.5) {
        // mirror around wedge center
        float halfS = 0.5 * sector;
        a = abs(a - halfS) - halfS;
      }

      // back to cartesian
      vec2 q = vec2(cos(a), sin(a)) * r;

      // back to uv
      vec2 uv = fromCentered(q, aspect);

      // gentle clamp so edges smear instead of hard black
      uv = clamp(uv, 0.001, 0.999);

      gl_FragColor = texture2D(u_tex, uv);
    }
  `;

  const compile = (type, src) => {
    const s = gl.createShader(type);
    gl.shaderSource(s, src); gl.compileShader(s);
    if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) throw gl.getShaderInfoLog(s);
    return s;
  };
  const prog = gl.createProgram();
  gl.attachShader(prog, compile(gl.VERTEX_SHADER, vsSrc));
  gl.attachShader(prog, compile(gl.FRAGMENT_SHADER, fsSrc));
  gl.linkProgram(prog);
  if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) throw gl.getProgramInfoLog(prog);
  gl.useProgram(prog);

  // fullscreen triangle
  const buf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buf);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    -1,-1,  3,-1,  -1,3
  ]), gl.STATIC_DRAW);
  const locPos = gl.getAttribLocation(prog, 'a_pos');
  gl.enableVertexAttribArray(locPos);
  gl.vertexAttribPointer(locPos, 2, gl.FLOAT, false, 0, 0);

  // uniforms
  const uTex = gl.getUniformLocation(prog, 'u_tex');
  const uRes = gl.getUniformLocation(prog, 'u_res');
  const uAngle = gl.getUniformLocation(prog, 'u_angle');
  const uZoom = gl.getUniformLocation(prog, 'u_zoom');
  const uSegs = gl.getUniformLocation(prog, 'u_segments');
  const uMirror = gl.getUniformLocation(prog, 'u_mirror');

  // texture for video
  const tex = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, tex);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

  const video = document.getElementById('v');
  const startBtn = document.getElementById('start');
  const flipBtn = document.getElementById('flip');
  const devSel = document.getElementById('device');

  const seg = document.getElementById('segments');
  const segVal = document.getElementById('segVal');
  const ang = document.getElementById('angle');
  const zoom = document.getElementById('zoom');
  const mirror = document.getElementById('mirror');

  let facing = 'environment';
  let stream = null;

  function resize() {
    const dpr = Math.min(2, window.devicePixelRatio || 1);
    const w = canvas.clientWidth;
    const h = Math.round(w * 16 / 9); // tall phone-friendly AR
    canvas.style.height = h + 'px';
    if (canvas.width !== w * dpr || canvas.height !== h * dpr) {
      canvas.width = w * dpr;
      canvas.height = h * dpr;
      gl.viewport(0, 0, canvas.width, canvas.height);
    }
    gl.uniform2f(uRes, canvas.width, canvas.height);
  }
  resize();
  addEventListener('resize', resize);

  async function listDevices() {
    const devices = await navigator.mediaDevices.enumerateDevices();
    devSel.innerHTML = '';
    devices.filter(d => d.kind === 'videoinput').forEach(d => {
      const opt = document.createElement('option');
      opt.value = d.deviceId;
      opt.textContent = d.label || `Camera ${devSel.length + 1}`;
      devSel.appendChild(opt);
    });
  }

  async function stopStream() {
    if (stream) stream.getTracks().forEach(t => t.stop());
    stream = null;
  }

  async function startStream(deviceId) {
    await stopStream();
    const constraints = {
      video: deviceId ? { deviceId: { exact: deviceId } }
                      : { facingMode: { ideal: facing }, width: { ideal: 1280 }, height: { ideal: 720 } },
      audio: false
    };
    stream = await navigator.mediaDevices.getUserMedia(constraints);
    video.srcObject = stream;
    await video.play();
    await listDevices(); // labels populate after permission
  }

  startBtn.onclick = async () => {
    try {
      await startStream();
    } catch (e) {
      alert('Camera permission or HTTPS required.\n' + e);
    }
  };

  flipBtn.onclick = async () => {
    facing = (facing === 'environment') ? 'user' : 'environment';
    await startStream();
  };

  devSel.onchange = async () => {
    const id = devSel.value;
    if (id) await startStream(id);
  };

  // draw loop
  function draw() {
    if (video.readyState >= 2) {
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, tex);
      // iOS needs this every frame for live video
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
      try {
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA,
                      gl.UNSIGNED_BYTE, video);
      } catch (e) {
        // swallow rare frame races
      }
      gl.uniform1i(uTex, 0);
      gl.uniform1f(uAngle, parseFloat(ang.value));
      gl.uniform1f(uZoom, parseFloat(zoom.value));
      gl.uniform1f(uSegs, parseFloat(seg.value));
      gl.uniform1f(uMirror, mirror.checked ? 1.0 : 0.0);

      gl.drawArrays(gl.TRIANGLES, 0, 3);
    }
    requestAnimationFrame(draw);
  }
  requestAnimationFrame(draw);

  seg.addEventListener('input', () => segVal.textContent = seg.value);
})();
</script>
</body>
</html>
